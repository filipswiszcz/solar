\chapter{Specyfikacja warstwy technologicznej}
 Silnik graficzny aplikacji został zaimplementowany od podstaw, co wymagało opracowania własnych rozwiązań w zakresie algebry liniowej, obsługi potoku OpenGL oraz zarządzania zasobami. 
 Poniższy rozdział stanowi dokumentację techniczną kluczowych modułów technologicznych, stanowiących fundament dla warstwy symulacyjnej.

    % 4.1
    \section{Dedykowana biblioteka matematyczna (\file{r\_math})}
     W celu uniknięcia zewnętrznych zależności (takich jak biblioteka GLM) oraz pełnego zrozumienia transformacji geometrycznych zachodzących w potoku graficznym, zaimplementowano autorski moduł matematyczny \file{r\_math}. 
     Biblioteka ta operuje bezpośrednio na surowych strukturach danych, co zapewnia kompatybilność binarną z układem pamięci oczekiwanym przez shadery GLSL.

        % 4.1.1
        \subsection{Implementacja typów wektorowych i macierzowych}
         Podstawą biblioteki są struktury wektorowe \var{vec2\_t}, \var{vec3\_t} oraz \var{vec4\_t}, reprezentujące odpowiednio punkty w przestrzeni 2D (współrzędne tekstur), 3D (pozycje, normalne) oraz 4D (kwaterniony, wektory jednorodne).
         Operacje arytmetyczne na wektorach (dodawanie, odejmowanie, mnożenie przez skalar) zaimplementowano w formie makr preprocesora (np. \texttt{\#define} \func{vec3\_add}), co pozwala na agresywną optymalizację kodu przez kompilator i unikanie narzutu wywoływania funkcji dla prostych operacji matematycznych.

         \bigbreak

         Macierze 4x4 zdefiniowano jako strukturę \var{mat4\_t} zawierającą dwuwymiarową tablicę \var{float m}. 
         Układ danych jest zgodny z formatem column-major stosowanym przez OpenGL, co umożliwia bezpośrednie przesyłanie macierzy do shaderów funkcją \func{glUniformMatrix4fv} bez konieczności ich transpozycji w locie.

         \newpage

        % 4.1.2
        \subsection{Kluczowe algorytmy transformacji}
         Moduł \file{r\_math.c} implementuje funkcje niezbędne do przekształcania współrzędnych z przestrzeni modelu do przestrzeni ekranu:

         \begin{itemize}
         \item[---] \textbf{Macierz widoku (\func{r\_look\_at}):} Konstruuje macierz transformacji kamery poprzez wyznaczenie ortonormalnej bazy wektorów: forward (kierunek patrzenia), right (iloczyn wektorowy forward i wektora up) oraz up (iloczyn wektorowy right i forward).
         \item[---] \textbf{Macierz projekcji (\func{r\_perspective}):} Generuje macierz rzutowania perspektywicznego, definiującą frustum widzenia (bryłę widokową). Funkcja przyjmuje kąt widzenia (FOV), proporcje ekranu (aspect ratio) oraz płaszczyzny obcinania near i far.
         \item[---] \textbf{Operacje na kwaternionach:} Do reprezentacji orientacji obiektów wykorzystano kwaterniony (\var{quat\_t}), co eliminuje problem blokady Gimbala (Gimbal Lock), charakterystyczny dla kątów Eulera. Funkcja \func{r\_rotate\_quat} konwertuje kwaternion rotacji na macierz 4x4, gotową do mnożenia z macierzą modelu.
         \end{itemize}

        % ZDJĘCIE=screen_frustrum_camera
        % Rysunek 4.1 Schemat ilustrujący frustrum kamery
         \bigbreak
         \bigbreak
         [RYSUNEK 4.1]
         \bigbreak
         \bigbreak

         \newpage

    % 4.2
    \section{Podsystem renderowania  (\file{r\_renderer})}
     Moduł renderera stanowi warstwę abstrakcji nad surowym API OpenGL 4.1. Jego zadaniem jest zarządzanie cyklem życia obiektów graficznych oraz optymalizacja wywołań rysowania.

        % 4.2.1
        \subsection{Abstrakcja obiektu graficznego (\var{object\_t})}
         Centralną strukturą renderera jest \var{object\_t}, zdefiniowana w pliku \file{r\_renderer.h}.
         Stanowi ona niezależny kontener danych, całkowicie odseparowany od logiki gry. Struktura ta agreguje:

         \begin{itemize}
         \item[---] \textbf{Siatkę (\var{mesh\_t}):} Zawiera bufory wierzchołków i indeksów oraz identyfikatory obiektów OpenGL (VAO, VBO, IBO).
         \item[---] \textbf{Materiał (\var{material\_t}):} Przechowuje właściwości optyczne powierzchni, takie jak współczynniki odbicia światła (ambient, diffuse, specular) oraz emisyjność.
         \item[---] \textbf{Transformację (\var{transform\_t}):} Lokalna pozycja, rotacja i skala obiektu.
         \item[---] \textbf{Zasoby:} Wskaźniki do używanego programu cieniującego (\var{shader\_t}) oraz tekstury.
         \end{itemize}

        % 4.2.2
        \subsection{Zarządzanie buforami OpenGL}
         Proces przesyłania geometrii do karty graficznej realizuje funkcja \func{r\_renderer\_object\_upload}. 
         Wykorzystuje ona mechanizm Vertex Array Object (VAO) do zapamiętania konfiguracji atrybutów wierzchołków. 
         Dane wierzchołków są przesyłane do bufora VBO w układzie interleaved (przeplatanym), gdzie w jednej strukturze \var{vertex_t} sąsiadują ze sobą: 
         
         \begin{enumerate}
         \item \textbf{Pozycja (3 x \var{float}):} \var{layout (location = 0)}
         \item \textbf{Normalna (3 x \var{float}):} \var{layout (location = 1)}
         \item \textbf{Współrzędne UV (2 x \var{float}):} \var{layout (location = 2)}
         \end{enumerate}

         Takie ułożenie danych w pamięci zwiększa lokalność odwołań cache GPU.
         Do rysowania wykorzystywany jest bufor indeksów (IBO) oraz funkcja \func{glDrawElements}, co pozwala na redukcję liczby przetwarzanych wierzchołków poprzez ich współdzielenie między trójkątami.

         \newpage

        % ZDJĘCIE=screen_vertex_buffer_structure
        % Rysunek 4.2 Diagram "Struktura Vertex Buffer Object"
         \bigbreak
         \bigbreak
         [RYSUNEK 4.2]
         \bigbreak
         \bigbreak

        % 4.2.3
        \subsection{Potok cieniujący (Shading Pipeline)}
         System wykorzystuje programowalne shadery napisane w języku GLSL 4.10. 
         Zaimplementowano dwa główne potoki renderowania:

         \begin{enumerate}
          \item \textbf{Rendering obiektów (Default Shader):} Shader fragmentów (\file{default.fs}) implementuje model oświetlenia Phonga/Blinna. Kolor finalny piksela obliczany jest na podstawie tekstury albedo (\var{u\_Texture}) oraz kąta padania światła (iloczyn skalarny wektora normalnego i wektora światła). Dodatkowo obsłużono parametr \var{u\_Emissive} (uniform typu int), który pozwala na renderowanie obiektów świecących własnym światłem (Słońce), ignorując obliczenia cieniowania.
          \item \textbf{Rendering tła (Skybox):} Do renderowania przestrzeni kosmicznej wykorzystano technikę Cube Mapping. Shader \file{skybox.fs} pobiera kolor z tekstury sześciennej (samplerCube) na podstawie wektora pozycji wierzchołka. W fazie rysowania (\file{g\_game.c}), macierz widoku jest modyfikowana poprzez wyzerowanie składowych translacji, co sprawia, że tło wydaje się być nieskończenie odległe względem obserwatora.
         \end{enumerate}

        \newpage

    % 4.3
    \section{System zarządzania zasobami 3D}
     W celu optymalizacji procesu ładowania aplikacji oraz zmniejszenia zużycia pamięci, zrezygnowano z bezpośredniego wczytywania formatów tekstowych (takich jak OBJ) w czasie rzeczywistym na rzecz własnego formatu binarnego oraz dedykowanego konwertera.

        % 4.3.1
        \subsection{Dedykowany format pliku \var{.orb}}
         Format \var{.orb} został zaprojektowany jako zrzut pamięci struktur silnika, co eliminuje konieczność kosztownego parsowania tekstu (\func{atoi}, \func{atof}) podczas uruchamiania gry.
         Plik składa się z trzech sekcji:

         \begin{enumerate}
         \item \textbf{Nagłówek:} Dwie 4-bajtowe liczby całkowite określające liczbę wierzchołków oraz liczbę indeksów.
         \item \textbf{Dane siatki:} Bezpośredni zrzut tablicy struktur \var{vertex\_t} oraz tablicy indeksów \var{uint32\_t}.
         \item \textbf{Definicja materiału:}: Blok danych odpowiadający strukturze \var{material\_t} (współczynniki oświetlenia, przezroczystość, gęstość).
         \end{enumerate}

         \bigbreak

         Dzięki takiej strukturze, funkcja \func{r\_renderer\_object\_read} może wczytać cały model za pomocą zaledwie kilku wywołań \func{fread}, co drastycznie skraca czas inicjalizacji sceny.

         \newpage

        % ZDJĘCIE=screen_example_orb_structure
        % Rysunek 4.3 Schemat "Struktura pliku binarnego .ORB"
         \bigbreak
         \bigbreak
         [RYSUNEK 4.3]
         \bigbreak
         \bigbreak

         \newpage

        % 4.3.2
        \subsection{Narzędzie \var{otob}}
         Narzędzie \var{otob} jest niezależnym programem konsolowym służącym do konwersji modeli Wavefront OBJ na format .orb. 
         Kluczowym wyzwaniem implementacyjnym była różnica w sposobie indeksowania: format OBJ stosuje oddzielne indeksy dla pozycji, normalnych i UV, podczas gdy OpenGL wymaga jednego indeksu per wierzchołek (unikalna kombinacja wszystkich atrybutów).


         Algorytm konwersji wykorzystuje autorską implementację tablicy haszującej (\var{map\_t}) z algorytmem haszującym FNV-1a.

         \begin{enumerate}
         \item Program parsuje ściany (\var{f}) pliku OBJ, odczytując tryplety indeksów (\var{v/vt/vn}).
         \item Dla każdego trypletu sprawdzane jest, czy taka kombinacja występuje już w mapie. Kluczem mapy jest wektor \var{vec3\_t} zawierający indeksy z pliku OBJ.
         \item Jeśli kombinacja jest nowa, tworzony jest nowy wierzchołek \var{vertex\_t} (poprzez scalenie danych z osobnych tablic źródłowych), dodawany jest do tablicy wierzchołków, a jego nowy indeks zapisywany jest w mapie.
         \item Jeśli kombinacja istnieje, do bufora indeksów (IBO) dodawany jest odzyskany z mapy indeks istniejącego wierzchołka.
         \end{enumerate}

         \bigbreak

         Taki proces zapewnia deduplikację wierzchołków, co jest kluczowe dla wydajności renderowania przy użyciu buforów indeksowych (\func{glDrawElements}).