\chapter{Analiza tematu i specyfikacja wymagań}

W niniejszym rozdziale przedstawiono teoretyczne podstawy zagadnienia, analizę dostępnych na rynku rozwiązań oraz zdefiniowano wymagania stawiane tworzonej aplikacji.

    % 1.1
    \section{Podstawy teoretyczne}

     Projekt łączy w sobie zagadnienia z dwóch dziedzin: mechaniki nieba oraz grafiki komputerowej. W kontekście astronomicznym, ruch ciał niebieskich w symulacji opiera się na uproszczonym modelu keplerowskim. Pozycja planety w przestrzeni trójwymiarowej wyznaczana jest na podstawie parametrów orbitalnych, takich jak: promień orbity, okres obiegu, inklinacja (nachylenie orbity względem płaszczyzny odniesienia) oraz długość węzła wstępującego.

     % ZDJĘCIE=screen_whole_r_physics_h
     % Rysunek 1.1
     \bigbreak
     \bigbreak
     [RYSUNEK 1.1]
     \bigbreak
     \bigbreak

     W aspekcie graficznym, aplikacja wykorzystuje programowalny potok renderujący (Programmable Pipeline) biblioteki OpenGL. Kluczową rolę odgrywają tu shadery, czyli małe programy wykonywane na procesorze graficznym (GPU), odpowiedzialne za przekształcanie wierzchołków (Vertex Shader) oraz ustalanie koloru pikseli (Fragment Shader).

     % ZDJĘCIE=screen_whole_default_vs, ZDJĘCIE=screen_whole_default_fs
     % Rysunek 1.2, Rysunek 1.3
     \bigbreak
     \bigbreak
     [RYSUNEK 1.2] [Rysunek 1.3]
     \bigbreak
     \bigbreak

     \newpage

    % 1.2
    \section{Przegląd istniejących rozwiązań}

     Na rynku istnieje wiele zaawansowanych symulatorów kosmosu, takich jak:

     % wymień przykłady i postaraj się znaleźć sens swojej aplikacji

    % 1.3
    \section{Słownik pojęć}

    \begin{enumerate}
        \item \textbf{Epoka J2000:} standardowa epoka astronomiczna używana jako punkt odniesienia dla współrzędnych niebieskich. W projekcie odpowiada dacie 1 stycznia 2000, godzina 12:00 czasu ziemskiego (TT). W kodzie symulacji (\file{r\_physics.c}) czas liczony jest jako liczba sekund, które upłynęły od tego momentu.
        \item \textbf{Pętla główna:} fundamentalny wzorzec architektoniczny w silnikach czasu rzeczywistego, polegający na cyklicznym wykonywaniu operacji obsługi wejścia, aktualizacji stanu logicznego (Update) oraz renderowania obrazu (Render). W projekcie realizowana przez funkcję \func{g\_game\_update} w pętli while (\func{!glfwWindowShouldClose}).
        \item \textbf{Inklinacja (Nachylenie orbity):}  jeden z elementów orbitalnych Keplera, określający kąt pomiędzy płaszczyzną orbity ciała niebieskiego a płaszczyzną odniesienia (w tym przypadku ekliptyką).
        \item \textbf{Kwaterion:} czterowymiarowa liczba zespolona używana w grafice komputerowej do reprezentacji obrotów w przestrzeni 3D.
        \item \textbf{Mapa sześcienna (Cube Map):} rodzaj tekstury składającej się z sześciu kwadratowych obrazów, reprezentujących ściany sześcianu otaczającego obserwatora. W projekcie wykorzystywana do renderowania tła (Skybox), obsługiwana w shaderze przez typ zmiennej \var{samplerCube}.
        \item \textbf{Macierz widoku (View Matrix):} macierz 4x4 transformująca współrzędne ze świata globalnego (World Space) do przestrzeni kamery (View Space). Generowana przez funkcję \func{r\_look\_at} na podstawie pozycji obserwatora i punktu skupienia wzroku.
        \item \textbf{Macierz projekcji (Projection Matrix):} macierz 4x4 odpowiedzialna za rzutowanie perspektywiczne przestrzeni trójwymiarowej na dwuwymiarową płaszczyznę ekranu, z uwzględnieniem kąta widzenia (FOV) i proporcji obrazu. Generowana przez funkcję \func{r\_perspective}.
        \item \textbf{Siatka (Mesh):} zbiór wierzchołków, krawędzi i ścian definiujący kształt obiektu 3D. W strukturze silnika (\var{mesh\_t}) składa się z buforów pozycji, normalnych oraz współrzędnych tekstury.
        \item \textbf{ORB:} binarny format plików modeli 3D zaprojektowany na potrzeby projektu. Przechowuje zrzut pamięci struktur wierzchołków i materiałów, co eliminuje konieczność parsowania tekstu w czasie rzeczywistym. Pliki te tworzone są przez narzędzie \var{otob}.
        \item \textbf{otob (Object to Binary):} narzędzie pomocnicze zaimplementowane w języku C, służące do konwersji modeli z formatu Wavefront OBJ do formatu binarnego ORB. Realizuje deduplikację wierzchołków przy użyciu tablicy haszującej.
        \item \textbf{Program cieniujący (Shader):} krótki program wykonywany na procesorze graficznym (GPU). W projekcie wykorzystywane są shadery wierzchołków (\var{.vs}) do transformacji geometrii oraz shadery fragmentów (\var{.fs}) do obliczania koloru pikseli.
        \item \textbf{Zmienna uniform:} rodzaj zmiennej w języku GLSL, która jest stała dla wszystkich wierzchołków/fragmentów w ramach jednego wywołania rysowania (np. macierze transformacji, pozycja światła).
        \item \textbf{VAO (Vertex Array Object):} obiekt OpenGL przechowujący konfigurację atrybutów wierzchołków (takich jak format danych, przesunięcia w pamięci). Pozwala na szybkie przełączanie między różnymi ustawieniami buforów bez konieczności ich ponownego definiowania w każdej klatce.
        \item \textbf{VBO (Vertex Buffer Object):}  bufor pamięci na karcie graficznej, przechowujący surowe dane wierzchołków (pozycje, normalne, UV).
        \item \textbf{Węzeł wstępujący (Ascending node):} punkt na orbicie, w którym ciało niebieskie przecina płaszczyznę odniesienia, przechodząc z półkuli południowej na północną. Jeden z parametrów pozycjonujących planetę w przestrzeni 3D (pole node w strukturze \var{planet\_t}).
    \end{enumerate}

    \newpage

    % 1.4
    \section{Wymagania funkcjonalne}

    %  Na podstawie analizy problemu zdefiniowano następujące funkcje systemu dostępne dla użytkownika:

    \begin{enumerate}
        \item \textbf{Symulacja układu planetarnego:} System musi wizualizować Słońce oraz 9 planet (wliczając Plutona) wraz z ich ruchem obrotowym i orbitalnym.
        \item \textbf{Interaktywna kamera:} Użytkownik musi mieć możliwość swobodnego przemieszczania się w przestrzeni za pomocą myszy i klawiatury (sterowanie typu \textit{first-person}).
        \item \textbf{Manipulacja czasem:} Użytkownik może przyspieszać czas (do skali lat na sekundę), zatrzymywać go oraz cofać, obserwując zmiany położenia planet.
        \item \textbf{System etykiet i orbit:} Ze względu na skalę kosmiczną, aplikacja musi renderować linie orbit oraz znaczniki (\textit{markery}) wskazujące pozycje planet, nawet gdy ich rozmiar geometryczny jest mniejszy niż jeden piksel na ekranie.
        \item \textbf{Obsługa układów satelitarnych:} System musi obsługiwać hierarchiczne relacje \textit{parent-child} (np. Księżyc krążący wokół Ziemi, która krąży wokół ciała centralnego).
        \item \textbf{Oświetlenie:} Obiekty muszą być cieniowane dynamicznie (np. z wykorzystaniem modelu oświetlenia Phonga) w zależności od ich położenia względem punktowego źródła światła (Słońca).
    \end{enumerate}

    % 1.5
    \section{Wymagania niefunkcjonalne}

     % tekst

    \begin{enumerate}
        \item \textbf{Wydajność:} Aplikacja musi utrzymywać płynność animacji na poziomie co najmniej 60 klatek na sekundę (FPS) przy renderowaniu pełnego układu słonecznego. Aktualny pomiar FPS ma być prezentowany użytkownikowi w pasku tytułu okna aplikacji w celu monitorowania obciążenia sprzętowego.
        \item \textbf{Zgodność ze standardami:} Kod źródłowy projektu musi być zgodny ze standardem języka C99 oraz normą POSIX, co ma zapewnić przenośność (\textit{portability}) między systemami operacyjnymi z rodziny Unix.
        \item \textbf{Efektywność ładowania danych:} Dzięki zastosowaniu binarnego formatu danych (\texttt{.orb}), czas wczytywania geometrii i inicjalizacji sceny powinien być zminimalizowany poprzez wyeliminowanie kosztownego parsowania tekstowego na rzecz bezpośredniego odczytu struktur do pamięci.
        \item \textbf{Zarządzanie pamięcią:} Aplikacja musi realizować ścisłą kontrolę alokacji pamięci operacyjnej i wideo, nie dopuszczając do wycieków pamięci (\textit{memory leaks}). Wszystkie zaalokowane zasoby (tekstury, bufory VBO/VAO, programy cieniujące) muszą być poprawnie zwalniane w fazie zamykania programu.
        \item \textbf{Modularność architektury:} System musi realizować separację warstwy renderowania od warstwy logicznej symulacji (zgodnie z wzorcem architektonicznym separacji odpowiedzialności), umożliwiając niezależny rozwój i testowanie obu modułów.
    \end{enumerate}

    % 1.6
    \section{Założenia techniczne projektu}

     Decyzje technologiczne podjęte w projekcie wynikają z chęci poznania niskopoziomowych mechanizmów działania komputerów.


     Język programowania C: Wybór języka C podyktowany jest koniecznością ręcznego zarządzania pamięcią (malloc/free) oraz operowania na wskaźnikach, co jest kluczowe dla wydajnej współpracy z sterownikami kart graficznych. Zrezygnowano z obiektowości C++ na rzecz struktur danych i funkcji operujących na stanie.


     OpenGL 4.1 Core Profile: Użycie nowoczesnego profilu OpenGL wymusza stosowanie shaderów i buforów VBO/VAO, eliminując przestarzałe funkcje (tzw. immediate mode). Zapewnia to zgodność z nowoczesnymi kartami graficznymi oraz systemem macOS.


     Dedykowany format .orb: Zamiast parsować tekstowe pliki .obj przy każdym uruchomieniu (co jest wolne i wymaga wielu alokacji pamięci), zaprojektowano format binarny .orb. Zawiera on gotowe zrzuty pamięci struktur wierzchołków, co pozwala na ich bezpośrednie wczytanie do RAM jednym wywołaniem fread.

     Brak bibliotek matematycznych: Zamiast popularnej biblioteki GLM, wszystkie operacje na macierzach 4x4 i wektorach (mnożenie, projekcja perspektywiczna) zaimplementowano własnoręcznie w module \texttt{r\_math}.

