\chapter{Implementacja logiki symulacji}
 Niniejszy rozdział skupia się na implementacji zasad fizyki orbitalnej, systemie zarządzania czasem oraz mechanizmach interakcji użytkownika z wirtualnym Układem Słonecznym.

    % 5.1
    \section{Fizyka i model danych ciał niebieskich (\file{r\_physics})}
     Model fizyczny aplikacji został zaprojektowany w oparciu o uproszczoną mechanikę nieba, wykorzystującą parametry orbitalne do deterministycznego wyznaczania pozycji ciał niebieskich w dowolnym momencie czasu.

        % 5.1.1
        \subsection{Struktura planety (\file{planet\_t})}

         \begin{itemize}
             \item[---] \textbf{Dane identyfikacyjne i wizualne:} Nazwa planety (\var{name}) oraz kolor bazowy (\var{color}) wykorzystywany przez elementy interfejsu.
             \item[---] \textbf{Elementy orbitalne Keplera:}
             \begin{itemize}
                 \item[---] \var{orbit.radius}: Średnia odległość od ciała centralnego
                 \item[---] \var{orbit.period}: Czas pełnego obiegu wokół orbity (rok gwiazdowy)
                 \item[---] \var{orbit.phase}: Przesunięcie początkowe, pozwalające ustalić pozycję planety w epoce startowej (np. J2000)
                 \item[---] \var{inclination}: Kąt nachylenia płaszczyzny orbity do płaszczyzny odniesienia (ekliptyki)
                 \item[---] \var{node}: Kąt określający orientację orbity w płaszczyźnie odniesienia
             \end{itemize}
             \item[---] \textbf{Parametry rotacyjne:} \var{spin} (okres obrotu wokół własnej osi) oraz \var{tilt} (nachylenie osi obrotu).
             \item[---] \textbf{Hierarchia:} Wskaźnik \var{struct planet *parent}, umożliwiający tworzenie układów zależnych (np. Księżyc krążący wokół Ziemi, która krąży wokół Słońca).
         \end{itemize}

         \newpage

        % ZDJĘCIE=screen_whole_context
        % Rysunek 5.1 Schemat "Elementy orbitalne Keplera"
         \bigbreak
         \bigbreak
         [RYSUNEK 5.1]
         \bigbreak
         \bigbreak

        % 5.1.2
        \subsection{Integracja z grafiką}
         Kluczowym aspektem architektury jest sposób połączenia warstwy fizycznej z warstwą prezentacji.
         Zamiast dziedziczenia, zastosowano kompozycję: struktura \var{planet\_t} zawiera wskaźnik \var{object\_t *object}.
        
         Obiekt graficzny (\var{object\_t}) przechowuje siatkę geometryczną, teksturę i shader, ale nie posiada wiedzy o swojej pozycji w kontekście astronomicznym.
         W każdej klatce symulacji, funkcja aktualizująca stan planety oblicza nową pozycję, a następnie modyfikuje macierz modelu (\var{u_Model}) powiązanego obiektu graficznego.

         Dzięki temu rozwiązaniu, renderer pozostaje niezależnym modułem, który jedynie "wyświetla" to, co obliczyła fizyka.
         Pozwala to również na łatwą zmianę reprezentacji wizualnej planety (np. podmianę modelu na dokładniejszy) bez ingerencji w kod fizyki.

         \newpage

        % 5.1.3
        \subsection{Algorytm pozycyjny}
         Wyznaczanie pozycji ciał niebieskich realizowane jest przez funkcję \func{r\_physics\_planet\_state\_update} oraz pomocniczą funkcję \func{r\_physics\_orbit\_to\_local}. 
         Proces ten przebiega w następujących krokach:

         \begin{enumerate}
             \item \textbf{Obliczenie anomalii średniej:} Na podstawie aktualnego czasu symulacji (\var{time}) wyznaczany jest kąt na orbicie (\var{orbit\_angle}). Uwzględnia się przy tym okres orbitalny oraz fazę początkową.
             \item \textbf{Wyznaczenie pozycji na płaszczyźnie orbity:} Współrzędne obliczane są przy założeniu orbity kołowej (dla uproszczenia mimośrodów bliskich zeru):
                 \begin{equation}
                 x = r \cdot \cos(\theta), \quad z = r \cdot \sin(\theta)
                 \end{equation}
             \item \textbf{Transformacja do układu lokalnego:} Pozycja jest poddawana obrotom zgodnie z parametrami orbitalnymi. Najpierw następuje obrót o kąt inklinacji wokół osi X, a następnie obrót o kąt węzła wstępującego wokół osi Y.
             \item \textbf{Uwzględnienie hierarchii:} Jeśli planeta posiada rodzica (pole parent nie jest NULL), do obliczonej pozycji dodawany jest wektor pozycji rodzica. Pozwala to na poprawne symulowanie układów satelitarnych.
         \end{enumerate}

    % 5.2
    \section{System czasu i kalendarza}
     Zarządzanie czasem jest krytycznym elementem symulacji astronomicznej, pozwalającym na obserwację zjawisk zachodzących w skali od minut do stuleci.

        % 5.2.1
        \subsection{Obsługa czasu rzeczywistego i symulowanego}
         Wewnętrzny zegar symulacji (\var{context.scene.clock.time}) reprezentowany jest przez zmienną typu double, przechowującą liczbę sekund, jakie upłynęły od epoki J2000 (1 stycznia 2000, 12:00 TT).
         Taka reprezentacja zapewnia wysoką precyzję i ułatwia obliczenia astronomiczne.

         W celu prezentacji daty użytkownikowi, zaimplementowano funkcję \func{r\_physics\_clock\_to\_tm}, która konwertuje czas liniowy na strukturę kalendarzową \var{struct tm} (rok, miesiąc, dzień).
         Wykorzystano w tym celu standardowe funkcje biblioteki C (\var{mktime, localtime_r}), traktując rok 2000 jako punkt odniesienia.

         \newpage

        % 5.2.2
        \subsection{Mechanizm sterowania upływem czasu}
         Aplikacja umożliwia dynamiczną zmianę prędkości upływu czasu. 
         Zaimplementowano to przy użyciu tablicy prędkości \var{speeds} oraz kursora wskazującego na aktualnie wybrany mnożnik. 
         Tablica zawiera wartości od ujemnych (cofanie czasu), przez zero (pauza), aż po wartości dodatnie symulujące upływ lat w ciągu sekund.

         W każdej klatce pętli głównej, czas symulacji jest inkrementowany o wartość: \var{delta_time} * \var{speeds[cursor]}.
         
         Sterowanie odbywa się za pomocą klawiszy klawiatury (H - zwolnienie/cofanie, K - przyspieszenie, J - reset do czasu rzeczywistego), co pozwala użytkownikowi na płynną nawigację w chronologii Układu Słonecznego.

         \newpage

    % 5.3
    \section{Interfejs i interakcja w przestrzeni 3D}
     Ze względu na specyficzną skalę kosmosu (ogromne odległości i stosunkowo małe obiekty), konieczne było zaprojektowanie elementów wizualnych ułatwiających orientację w przestrzeni.

        % 5.3.1
        \subsection{Wizualizacja orbit}
         Linie orbit nie są częścią modeli 3D, lecz są generowane proceduralnie podczas inicjalizacji sceny (\func{g\_game\_ui\_orbits\_init}). 
         Algorytm iteruje przez kąt od $0$ do $2\pi$ z zadanym krokiem, wykorzystując tę samą funkcję fizyczną \func{r\_physics\_orbit\_to\_local}, która służy do pozycjonowania planet.

         Wygenerowane wierzchołki są przesyłane do osobnego bufora VBO i rysowane jako prymityw \var{GL_LINE_LOOP}. 
         Dzięki temu orbity idealnie pokrywają się z trajektorią ruchu planet, uwzględniając ich inklinację i ekscentryczność.
         Do ich renderowania użyto dedykowanego shadera (\file{orbit.vs}, \file{orbit.fs}), który umożliwia nadanie im stałego koloru i jasności, niezależnie od oświetlenia słonecznego. 

        % ZDJĘCIE=screen_orbits
        % Rysunek 5.2 ""
         \bigbreak
         \bigbreak
         [RYSUNEK 5.2]
         \bigbreak
         \bigbreak

         \newpage

        % 5.3.2
        \subsection{System markerów i nawigacja}
         Aby planety były widoczne nawet z dużej odległości, zastosowano system markerów. 
         Są to proste okręgi rysowane wokół pozycji planety. 
         Marker jest skalowany w taki sposób, aby był zawsze zauważalny, ale skalowanie to odbywa się w shaderze lub poprzez macierz modelu markera (\var{model_marker}), która jest niezależna od skali samej planety.


         Nawigacja w przestrzeni trójwymiarowej została zrealizowana w modelu "Free Look" (swobodna kamera).

         \begin{enumerate}
             \item \textbf{Mysz:} Ruch myszy modyfikuje kąty Eulera kamery (\var{yaw, pitch}), na podstawie których wyliczany jest wektor kierunku patrzenia (\var{target\_position}).
             \item \textbf{Klawiatura:} Klawisze W/S/A/D przesuwają pozycję kamery wzdłuż wektorów lokalnych (przód/tył oraz lewo/prawo), wyznaczanych jako iloczyn wektorowy kierunku patrzenia i wektora "góry" (\var{head\_position}). Klawisz SHIFT modyfikuje wartość \var{speed} kamery, pozwalając na zmianę prędkości poruszania.
         \end{enumerate}

         Implementacja ta, zawarta w \func{g\_game\_handle\_mouse} i \func{g\_game\_handle\_keyboard}, pozwala na intuicyjne przemieszczanie się po Układzie Słonecznym i obserwację zjawisk z dowolnej perspektywy.